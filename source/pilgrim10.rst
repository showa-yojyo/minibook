======================================================================
入門 HTML5 読書ノート
======================================================================

.. admonition:: 読者ノート

   なにぶん古い図書なので、

   * リンク切れの URL は可能な範囲で更新する（無意味かもしれない）。
   * Internet Explorer に関する記述は無視する。

:著者: Mark Pilgrim
:訳者: 水原文
:監訳者: 矢倉眞隆
:出版社: オライリー・ジャパン
:発行年: 2011 年
:ISBN: 978-4-87311-482-8

監訳者まえがき
======================================================================

この書籍の概要は次のとおり：

   本書『入門 HTML5』は、Google で Developer Advocate を務める Mark Pilgrim によ
   る HTML5 と周辺技術の書籍『HTML5: Up and Runing』の日本語訳になります。

`Developer Center <https://cloud.google.com/developers/advocates>`__ で
Developer Advocate なる役職の一覧が確認できる。役割の詳細もそこに述べられている。

   この原著、その原稿やデモすべてが Creative Commons の Attribution ライセンスの
   もと、`Dive Into HTML5 <http://diveintohtml5.info>`__ というサイトで公開され
   ています。

ということは、紙の本から読書ノートを綴らなくとも、つねに最新版である原稿を公開し
ている上記サイトを読めば良かったかもしれない。

まえがき
======================================================================

本書で焦点が当たるトピックが箇条書きになっている。本ノートの見通しをよくするため
にも控えておく：

   * ``<header>``, ``<footer>``, そして ``<section>`` などの新たな意味要素 (3
     章)
   * JavaScript でプログラム可能な二次元の図形描画機能、Canvas (4 章)
   * サードパーティ製プラグインの助けを借りずに Web へ埋め込み可能なビデオ (5
     章)
   * Web アプリケーションへ、自分の居る位置を通知できる位置情報通知機能 (6 章)
   * サードパーティ製プラグインを必要としない永続的ローカルストレージ (7 章)
   * ネットワークアクセスが切断された後でも動作可能なオフライン Web アプリケー
     ション (8 章)
   * 改良された HTML フォーム (9 章)
   * HTML5 にはない語彙を作成し、Web ページに独自の意味づけが可能なマイクロデー
     タ

個人的に興味があるのは第 3, 4, 9 章だ。ビデオ編集する習慣があることから第 5 章も
参考になる。

.. contents::

1 章 ここまでの道のり
======================================================================

著者が《心の片隅に留めておいて欲しい》という言葉をほぼ引用しておく：

   実装と詳細の間には、微妙な関係を保つ必要がある。使用が完成する前に実装が行わ
   れることは望ましくない。なぜならば、既存の実装の詳細に引きずられ、仕様が制約
   されてしまうからだ。しかし、実装されたものが利用されないまま仕様が完成するこ
   ともまた望ましくない。なぜならば、利用者からのフィードバックが必要だからだ。

実装と詳細は、一方が「主」で他方が「従」ということではないということか。

この後は読み物のようなテキストが続く。:abbr:`WHATWG (Web Hypertext Application
Technology Working Group)` の誕生くらいまで読み流す感じでいい。

   十年に及ぶ HTML への投資を無駄にし、また既存 Web ページの 99 パーセントを使え
   なくする代わりに、WHATWG は別のアプローチを取ることにした。ブラウザが実際に利
   用している「寛大な」エラー処理アルゴリズムを文書化することだ。

これは解析だ。

   そして、2006 年 10 月、ついに W3C の創設者である Tim Berners-Lee が、HTML の進
   化のために W3C が WHATWG と経堂で作業を進めることを発表した。

和解のようなものと考えられる。なお、:abbr:`W3C (World Wide Web Consortium)` とい
う用語は、私の読み抜けがなければ、何の説明もなしに本文に登場した。

   再設立され、生まれ変わった W3C HTML ワーキンググループが最初に行った決定のひ
   とつは、「Web Application 1.0」を「HTML5」と改名することだった。

引用しなかったが、Web Application 1.0 とは解析作業と並行して進行していたキャンバ
ス、ビデオサポート等のドラフトだ。

2 章 HTML5 の機能を検出する
======================================================================

   HTML5 はひとつの大きなものではなく、個別の機能が集まったものなのだ。

したがって、例えば「キャンバスは対応済みか？」「ビデオは対応済みか？」などを調べ
ることをこの章では検討していく。

   ブラウザが特定の機能をサポートしているかどうかを検出するための、基本的なテク
   ニックは 4 つある。

本文の技法一覧を単純化して列挙しておく：

1. ``window`` や ``navigator`` グローバルオブジェクトに対して、特定のプロパ
   ティーが存在するかを調べる。
2. ``new`` した要素に対して特定のプロパティーが存在するかを調べる。
3. ``new`` した要素に対して特定のメソッドが存在するかを調べる。それを呼び出して
   戻り値を調べる。
4. ``new`` した要素に対してプロパティーを特定の値に設定し、それが値を保持してい
   るかを調べる。

以上は、当然ながら JavaScript コードを走らせて検出する。

   `Modernzir <https://modernizr.com/>`__ は、オープンソースで MIT ライセンス
   の、数多くの HTML5 と CSS3 機能のサポートを検出してくれる JavaScript ライブラ
   リだ。

この JS ファイルをローカルに用意して ``<head>`` 内から ``<script>`` で読み込ませ
れば利用可能になる。オブジェクト ``Modernizr`` にブラウザーが特定の機能に対応し
ているかどうかを示すフラグを持っている。例えばキャンバスを使いたければ真偽値
``Modernizr.canvas`` を調べるという具合だ。本章はこのように、個別機能と検出方法
紹介を並べる構造になっているが、本ノートでは割愛する。現代的ブラウザーではどうせ
対応されているので。

   ブラウザが HTML5 ビデオをサポートしていない場合には、``<video>`` 要素として作
   成された DOM オブジェクトは共通プロパティのみを持っているはずだ。

この考え方はビデオ以外の HTML5 新機能についても成り立つ。興味があるので、ビデオ
に関する記述を中心に引用する。

「コーデック」を次のように定義している：

   ビデオをビットストリームへエンコードする際に使われるアルゴリズムのことだ。

先程の判定論理の「裏」が述べられる：

   ブラウザが HTML5 ビデオをサポートしていれば、``<video>`` 要素として作成された
   DOM オブジェクトは ``canPlayType()`` メソッドを持っているはずだ。

ローカルストレージの節の冒頭：

   HTML5 のストレージは、ウェブサイトがコンピュータに情報を保存して後で使うため
   の手段を提供する。概念としてはクッキーに似ているが、より大きな情報量を取り扱
   えるように設計されている。

本書の後半で一章割いて説明される。

本書では「マークアップ教授に質問」という質問と回答形式の囲み記事が随所に現れる。
次の概念は重要なので引用する：

   ブラウザの中では、どの Web サイトも自信が保存した値を読んだり変更したりできる
   が、別のサイトが保存した値へのアクセスはできない。このことは、同一生成元制約
   (same-origin restriction) と呼ばれている。

``<input>`` 要素の ``type`` 属性になり得る値が HTML5 で急増したことが述べられて
いる。他にも、

   プレースホルダは、そのフィールドが空で、かつそこにフォーカスがない場合に入力
   フィールド中に表示される

機能がある。また、フォーカスに関しては、

   HTML5 はすべてのフォームコントロールに ``autofocus`` 属性を導入した。この
   ``autofocus`` 属性は、フォーカスを特定のフィールドへ移動するという、文字通り
   の働きをする。

最後に、聞き馴染みのない機能を知る：

   マイクロデータは、Web ページに意味付けを追加するための標準的な方法だ。例え
   ば、マイクロデータを使ってある写真が特定のクリエイティブコモンズライセンスで
   利用できることを宣言できる。

3 章 HTML 文書の構造と意味付け
======================================================================

この章では XHTML 1.0 文書を HTML5 に改良していくという実践的なものだ。以前、自作
の古いページを書き直す時にこの記述を大いに利用した。サンプルページはこれ：
<http://diveintohtml5.info/examples/blog-original.html>

   少なくとも一度は「ソースを表示」してみてから、この先を読み進めて欲しい。

当該 HTML を画面に表示しながら本章を読んでもいい。

DOCTYPE の記述は単純に済ませるのが HTML5 だ：

   これがその、HTML5 の DOCTYPE だ。

   .. code:: html

      <!DOCTYPE html>

   これだけ。だった 15 文字だ。手で打つのも簡単だし、間違えることもないだろう。

VS Code でコードを編集するのであれば補完候補に現れるからさらに楽だ。

   DOCTYPE は、HTML ファイルの最初の行に存在する必要がある。

次にルート要素である ``<html>`` を改良している。やはり単純だ。

* ``xmlns`` 属性は必要ない。
* ``lang`` 属性があれは ``xml:lang`` 属性は不要だ。

どうも HTML ファイルの先頭から末尾に向かって改良しているらしい。次は ``<head>``
に着手。

   ルート要素の最初の子要素は、普通 ``<head>`` 要素だ。

文字エンコーディングの宣言を書き換える：

   実は、HTML5 ではその（引用註：``<meta>`` タグ）使い方も少しやさしくなってい
   る。以下のように書けるのだ。

   .. code:: html

      <meta charset="utf-8" />

   これは、すべてのブラウザで動作する。

マークアップ教授と著者から共通する警告：

   **すべての** HTML 文書には **常に** 文字エンコーディングを指定すべきであり、
   そうしないといろいろとまずいことが起こるだろう。（略）どの方法でもいいから確
   実に行ってほしい。

個人的に軽視していた ``<link>`` タグについての記述が参考になる。

   リンクタイプは、別のページを参照する **理由** を説明するためのものだ。「私が
   ここで別のページを参照しているそのわけは…」に続く文章を作っていると考えればよ
   い。

HTML5 はリンクによる関連付けを二つに区分しているとして、次の記述を引用している：

   Two categories of links can be created using the link element: links to
   external resources and hyperlinks.
   （略）
   The exact behavior for links to external resources depends on the exact
   relationship, as defined for the relevant link type.
   (<https://html.spec.whatwg.org/multipage/semantics.html#attr-link-rel>)

サンプルページでは CSS ファイルに関する ``<link>`` だけが外部リソースへのリンク
に当てはまるとある。

``<meta rel="archives" ...>`` をブログの過去記事索引に使えるとある。後で試した
い。総索引ページにこのタグを書く感じか。

HTML5 の新しい意味要素として pp. 45-46 に列挙されているもののほとんどが改良作業
で重要だ。

   すべてのブラウザは不明な要素をインラインレベル要素として表示する。

ので、

   HTML5 の新しい要素のいくつかは、ブロックレベル要素として定義されている

ものを旧式ブラウザーで描画させようとすると、明らかにおかしくなる。CSS による回避
策が本書に与えられている。

``<div id="header">`` のようなブロックが文書にあれば、それを ``<header>`` に置き
換えることを検討する価値がある：

   HTML5 では、``<header>`` 要素がこの目的のために定義されている。

----

   HTML4 では、文書のアウトラインを作成する方法が ``<h1>`` ～ ``<h6>`` **だけ**
   しかなかった。

ワープロソフトの類比から、そういうものだと思っていた。

   ``<hgroup>`` 要素は、二個またはそれ以上の **関連する** 見出し要素をグループ化
   する働きをする。ここで「関連する」とは、全体として文書アウトライン中で単一の
   ノードを形成するという意味だ。

見本コードを確認すると ``<hgroup>`` の中に ``<h1>``, ``<h2>`` がこの順序で現れて
いる。``<hgroup>`` を抜けると、個別の ``<h2>`` が現れる。

----

HTML5 ``<article>`` 要素は、部分文書を構成すると私には読める。

   この HTML5 のアルゴリズム（引用註：新しい意味要素を採用した文書アウトライン生
   成アルゴリズム）では、``<article>`` 要素は新しいセクション、つまり新しいノー
   ドを文書アウトラインに生成することになっている。そして HTML5 では、セクション
   ごとに ``<h1>`` 要素が持てるのだ。

このおかげで見出し番号を気にすることなく ``<article>`` ノード部分をコピーペース
ト可能になった。

----

日付と時間を表現するための新しい要素を紹介している：

   ``<time>`` 要素は、三つの部分に分けられる。

   * 機械可読なタイムスタンプ
   * 人間が読むためのテキスト
   * オプションの ``pubdate`` フラグ

第一項目は ``datetime`` 属性値に記すようだ。第二項目が要素の値で、空であってもか
まわないらしい。それどころか《テキストは何でもよいのだ》。

   この ``pubdate`` 属性の意味するところは、以下の二つのどちらかだ。まず
   ``<time>`` 要素が ``<article>`` 要素の中にある場合、このタイムスタンプはその
   記事が公開された日付であることを意味する。また ``<time>`` 要素が
   ``<article>`` 要素の中にない場合、このタイムスタンプは文書が公開された日付で
   あることを意味する。

この仕様ならばブログ型のページ、特に検索結果ページを作りやすくなるだろう。

----

   HTML5 では、ナビゲーションのセクションをマークアップするための意味的な方法が
   用意されている。それが、``<nav>`` 要素だ。

``<div id="nav">`` 区画を ``<nav>`` に自然に置き換える。

----

   ``<footer>`` 要素を使うのにふさわしい場所はどこだろうか。おそらく、現在
   ``<div id="footer">`` としている場所すべてだろう。

4 章 Canvas による描画
======================================================================

WebGL をやったことがあるので ``<canvas>`` 要素は馴染みがある。この章の内容をその
理解の確認に使える。

   HTML5 は ``<canvas>`` を「解像度に依存するビットマップ描画機能で、グラフ、
   ゲームのグラフィックス、あるいはその他のビジュアル画像をオンザフライで表示で
   きる」と定義している。

飛行中で表示できるとは何だという疑問が湧く。この先を読むことで明らかになる。

   Canvas そのものは目には見えない。``<canvas>`` 要素自身は何の内容も持たず、ま
   たボーダーも指定されていないからだ。

この事実は WebGL のコードを書きまくったときに体で知った。

JavaScript コードを書く。DOM 中の ``<canvas>`` 要素が ``document`` から得られた
とする。描画をするに当たって最初にすることは、

   その ``getContext()`` メソッドを呼び出す。``getContext()`` メソッドには、
   **必ず** 文字列 ``"2d"`` を渡さなくてはならない。

WebGL 描画の場合には ``"webgl"`` を渡さなくてはならない。次のページ (p. 67) の脚
注によると、本書発行時には仕様策定中だったらしい。

平面図形については Win32 GDI を扱う感覚で、図形に対応するメソッドを呼び出す。

* ``.fillStyle``
* ``.fillRect(x, y, width, height)``
* ``.strokeStyle``
* ``.strokeRect(x, y, width, height)``
* ``.clearRect(x, y, width, height)``

キャンバスの座標系はスクリーン座標系と同じ向きだ：

   座標 (0, 0) は Canvas の左上隅に対応する。X 軸の値は、Canvas の右側に近づくに
   したがって増加する。Y 軸の値は、Canvas の下端に近づくにしたがって増加する。

パスの考え方も Win32 GDI と同様だ。

* ``.beginPath()``
* ``.moveTo(x, y)``
* ``.lineTo(x, y)``
* ``.stroke()``

本書は鉛筆メソッドとインクメソッドという術語でコンテキストのメソッドの働きを上
手く説明している。

----

テキスト描画のインターフェイスも Win32 GDI に似ている。描画コンテキストを介して
フォント属性を操作する。

* ``.font``
* ``.textAlign``
* ``.textBaseline``
* ``.fillText(text, x, y)``
* ``.strokeText(text, x, y)``

----

   円を描く方法については後で説明するが、ここではちょっとずるをして矩形を描いて
   済ませることにしよう。

寸法の小さい矩形を描けば、遠目からは円に見える。

----

   シェープや線は単色以外で描くこともできる。グラデーションを使えば、いろいろな
   効果が楽しめる。

次の二つのメソッドがグラデーション塗りを実現するものだ。放射状版は同心円でなくて
もいいとは：

* ``.createLinearGradient(x0, y0, x1, y0)``
* ``.createRadialGradient(x0, y0, r0, x1, y1, r1)``

これらの戻り値のプロパティーに対して色指定を行う。

* ``.addColorStop(offset, color)``: ``offset`` は 0..1 の値で指定。

グラデーションは対象図形に設定しなければ意味がない。

   グラデーションを描くには、``fillStyle`` をグラデーションに設定し、矩形や直線
   などのシェープを描けばよい。

----

画像をキャンバスに描く方法。ここが予想に反して重要。

   Canvas に画像を描くには、まず画像が必要だ。画像は既存の ``<img>`` 要素でもい
   いし、JavaScript を使って作成した ``Image()`` オブジェクトでもよい。

本書 p. 81 と p.82 それぞれのコード片の構造を頭に叩き込め。より現代的なコードを
目にすることがあり、これがその基本形だ。

----

`Halma <http://diveintohtml5.info/examples/canvas-halma.html>`__ 実装例に目を通
す。キャンバスモノでよくある、マウスクリック位置を検出する課題に関するコツを知
る：

   実は、マウスイベントはブラウザによって異なる実装がされているので、これはなか
   なか難しいことなのだ。

   （略）

   「マウスクリック」→「文書の相対座標」→「Canvas 相対座標」→「アプリケーション
   特有のコード」という流れになることは覚えておいてほしい。

コードを見ると、参照する可能性がある値は次だ：

* マウスイベント ``.pageX``, ``.pageY``
* マウスイベント ``.clientX``, ``.clientY``
* 文書本文 ``.scrollLeft``, ``.scrollTop``
* ルート要素 ``.scrollLeft``, ``.scrollTop``
* キャンバス ``.offsetLeft``, ``.offsetTop``

5 章 Web のビデオ
======================================================================

この章の記述は HTML5 というより、ビデオファイルの解説がありがたい。

   HTML5 では、``<video>`` 要素を使って Web ページにビデオを埋め込む標準的な方法
   が定義されている。

そのタグについての詳細を説明する準備として、ビデオファイルの構造に関する解説が先
だ。

   実は、「AVI」や「MP4」はコンテナフォーマットに過ぎないのだ。ZIP ファイルがど
   んな種類のファイルでも圧縮できるように、コンテナフォーマットはその中にデータ
   を格納する **方法** を定義しているだけで、データの **種類** については規定し
   ていない。

VLC はいいソフトなのでインストールしておきたい。

----

   :dfn:`ビデオコーデック` とは、ビデオストリームがエンコードされる際に使われる
   アルゴリズムのことだ。（「コーデック (codec)」とは「コーダ (coder)」と「デ
   コーダ (decoder)」の合成語だ。）

FFmpeg 操作時には世話になっている H.264 だが、

   **H.264 標準は、特許に縛られている。**

----

   ビデオにはない概念がオーディオにはある。それは **チャンネル** だ。

..

   ひとつひとつのスピーカーは、録音された特定の **チャンネル** を再生する。

..

   MP3 は、音のチャンネルを **二個** まで持てる。

..

   音質とビットレートとは線形比例するわけではない。

..

   **MP3 フォーマット（1991 年に標準化）は特許に縛られている。**

これまた FFmpeg 操作時に世話になっている :abbr:`AAC (Advanced Audio Coding)` だ
が、

   **AAC フォーマットは特許に縛られている。**

..

   AAC は音声チャンネルを **48 個まで** エンコードできるが、実際に試した人は誰も
   いないだろう。

----

ここまで映像と音声の符号形式を多数紹介したのは、``<video>`` 要素の書き方に関する
説明を読者に理解させるための準備だとわかる。

   ひとつの ``<video>`` 要素は複数のビデオファイルにリンクすることができ、ブラウ
   ザは自分が再生可能な最初のビデオファイルを選択する。 **どのブラウザがどのコン
   テナやコーデックをサポートしているかどうかを理解するのは、あなたの責任なの
   だ。**

ブラウザーは ``<video>`` タグ自体には対応しているが、どんな形式（側面が上記の二
つあることに注意）のビデオファイルでも再生可能であるという意味ではない。

----

ビデオ変換ツールの記述 (pp. 102-124) は今は読み飛ばす。私は FFmpeg しか使わな
い。

----

``<canvas>`` とは違い、

   ブラウザは ``<video>`` タグで指定したボックス内の中央にビデオを表示してくれ
   る。勝手に比率が変更されて、つぶれたり引き伸ばされたりすることはない。

----

   デフォルトでは ``<video>`` 要素は再生コントロールの類を何も提供しない。（略）

   自分でインタフェースを作るつもりがなければ、ブラウザに組み込みのコントロール
   を表示させることもできる。これを行うには、``<video>`` タグに ``control`` 属性
   を追加するだけでよい。

ブラウザーにもよるのだろうが、組み込みのコントローラーは YouTube のそれに比較す
ると機能が貧弱でありがちだ。

----

``<video>`` 要素には子ノードとしてビデオファイル一つを指す ``<source>`` 要素を通
常持つ。同一内容のビデオファイルを複数用意しておいて、それぞれに対応する
``<source>`` 要素を併記する。

   もしブラウザに前もってビデオの形式を教えておくことができれば、ネットワークト
   ラフィックを大幅に節約できる。これは、``<source>`` 要素の ``type`` 属性を使っ
   て行う。

子要素 ``<source>`` の記載順序は重要だ：

   ブラウザがそのビデオを再生できないと判断したら、**そのファイルはダウンロード
   しない。**

----

本章の内容を総合したコマンドライン、HTML および JavaScript コードで締めくくられ
る。ここまで手間をかけてでも公に見てもらいたいビデオなどは当面のところ持ち合わせ
ていないので、理屈を理解できればこの章は十分とする。

6 章 Geolocation API による位置情報通知
======================================================================

7 章 Web アプリケーションのローカルストレージ：その過去・現在・未来
======================================================================

8 章 オフライン状態での動作
======================================================================

9 章 Web フォーム
======================================================================

10 章 マイクロデータによるマークアップの拡張
======================================================================

付録 A （ほぼ）アルファベット順の HTML5 機能機能方法
======================================================================

.. 以上
